
# c语言便利贴

> 1

    简单的语句就是命令
    快语句被{}包围
    switch语句高效的检查了一个变量的多种取值
    每个程序都需要一个main()函数
    需要在运行之前先编译c程序
    #include将外部代码（如用来输入输出的代码）包含进来
    可以用&&和||把多个条件组合在一起
    gcc是最流行的C编译器
    源文件的文件名应该以.c结尾
    -o指定了输出文件
    只要条件为真，while就会重复执行代码
    do-while至少执行一次代码
    用for写循环更简洁

> 2

    scanf(“ % i”,&x)可以让用户直接输入数字x
    不同计算机的int的大小不同
    &x返回x的地址
    &x称为指向x的指针
    char指针变量x可以这么声明：char *x
    字符串字面值保存在只读存储器中
    用字符串初始化数组，数组会复制字符串中的内容
    局部变量保存在栈上
    数组变量可以用作指针
    用*a读取地址a中的内容
    可以简单地用fgets(buf, size, stdin)输入文本

> 2.5

    string.h头文件包含了有用的字符串处理函数
    字符串数组是数组的数组
    可以用char strings[...][...]创建数组的数组
    strstr(a, b)可以返回字符串b在字符串a中的地址
    strchr()用来在字符串中找到某个字符的位置
    strcmp()可以比较字符串
    strcpy()可以复制字符串
    strcat()可以连接字符串
    strlen()可以得到字符串的长度

> 3

    标准输入默认从键盘读取数据
    标准错误专门用来输出错误消息
    标准输出默认在显示器上显示数据
    用getopt()函数读取命令行选项很方便
    命令行参数以字符串指针数组的形式传递给main()
    可以用fopen(“文件名”, 模式)创建你自己的数据流
    三种模式分别是w（写入）、r（读取）、a（追加）
    可以用fprintf(stderr,…)把数据打印到标准错误
    printf()和scanf()使用标准输出和标准输入来交互
    printf()的实现是fprintf(stdout,…);
    可以用重定向把标准输入、标准输出和标准错误连接到其他地方。
    < 标准输入  > 标准输出   2> 标准错误

> 4

    char是数值。
    小整数用short。
    大整数用long。
    普通整数用int。
    一般的浮点数用float。
    高精度的浮点数用double。
    函数的声明与定义分离。
    把声明放在头文件中。
    用#include“”包含本地头文件。
    用#include<>包含标准库头文件。
    把目标代码保存到文件中，提高构建速度。
    使用make管理代码构建过程。

> 5

    结构把数据类型组合在一起。
    可以用“点表示法”读取结构中的字段
    可以像初始化数组那样初始化结构。
    可以用typedef为数据类型创建别名。
    有了“->”表示法，就能用结构指针更新字段，十分方便。
    联合可以在同一个存储器单元中保存不同的数据类型。
    可以用“指定初始化器”按名设置结构或联合的字段。
    可以用枚举创建一组符号。
    可以用位字段控制结构中的某些位。

> 6

    链表比数组更容易扩展。
    在链表中插入数据很方便。
    链表是动态数据结构。
    动态数据结构使用递归结构。
    递归结构包含一个或多个链向相同结构数据的链接。
    malloc()在堆上分配存储器。
    free()释放堆上的存储器。
    与栈不同，堆存储器不会自动释放。
    栈用来保存局部变量。strdup()会把字符串复制到堆上。
    存储器泄漏是指存储器分配出去以后，你再也访问不到。
    valgrind可以帮助追踪存储器泄漏。

> 7

    有了函数指针，就可以把函数当数据传递。
    函数指针是唯一不需要加*和&运算符的指针……(……只要你想，也可以加上它们。)
    每个函数的名字都是一个指向函数的指针。
    qsort()会排序数组。
    排序函数接收比较器函数指针。
    比较器函数决定如何排序两条数据。
    有了函数指针数组，就可以根据不同类型的数据运行不同的函数。
    参数数量可变的函数叫“可变参数函数”。
    包含stdarg.h，就可以创建可变参数函数。

> 8

    #include<>会查找包括 /usr/include在内的标准目录。
    gcc -shared把目标文件转化为动态库。
    ar命令创建目标文件的存档。
    -L < 路径名 > 在标准lib目录列表中添加目录。
    库存档名形如 libXXX.a。
    -l < 路径名 > 会链接标准目录（例如/usr/lib）下的文件。
    -I < 路径名 > 在标准include目录列表中添加目录。
    库存档是静态链接的。
    动态库在运行时链接。
    动态库在不同的操作系统上有不同的名字。
    动态库的后缀名有.so、.dylib、.dll和.dll.a等。

> 9

    system()会把字符串当成命令运行。

    execl() = 参数列表
    execle() = 参数列表 + 环境变量
    execlp() = 参数列表 + 搜索PATH
    execv() = 参数数组
    execve() = 参数数组 + 环境变量
    execvp() = 参数数组 + 搜索PATH

    fork()复制当前进程。
    fork()+exec()创建子进程。

> 10

> ---

    // 信号 (操作系统可以向进程发送各种信号)部分..
    SIGINT  =>  进程被中断
    SIGQUIT =>  有人要求停止进程，并把存储器中的内容保存到核心转储文件。
    SIGFPE  =>  浮点错误。
    SIGTRAP =>  调试人员询问进程执行到了哪里。
    SIGSEGV =>  进程企图访问非法存储器地址。
    SIGWINCH    =>  终端窗口的大小发生改变。
    SIGTERM =>  有人要求内核终止进程。
    SIGPIPE =>  进程在向一个没有人读的管道写数据。

> ---

    exit()立即终止程序。
    fileno()查找描述符。
    dup2()复制数据流。
    waitpid()等待进程结束。
    pipe()创建通信管道。
    进程可以用管道通信。
    信号是O/S发出的消息。
    用sigaction()处理信号(自定义处理信号器)。
    kill命令发送信号。
    程序可以用raise()向自己发送信号。
    alarm()会在几秒钟以后向进程发送SIGALRM信号。

> 11

    telnet是一个简易网络客户端。
    用socket()函数创建套接字。
    服务器BLAB四部曲：
        B  = bind()
        L  = listen()
        A  = accept()
        B  = 开始对话
    用fork()克隆子进程，同时处理多个客户端。
    DNS = 域名系统
    getaddrinfo()根据域名找地址。

> 12

    普通进程一次只做一件事。
    有了线程，进程一次就能做多件事。
    线程是“轻量级进程”。
    POSIX线程(pthread)是一个线程库。
    pthread_create()创建线程来运行函数。
    pthread_join()会等待线程结束。
    线程共享相同的全局变量。
    如果线程读取并更新了相同变量，代码的运行结果将不可预测。
    互斥锁是用来保护共享数据的锁。
    pthread_mutex_lock()在代码中创建互斥锁。
    pthread_mutex_unlock()释放互斥锁。