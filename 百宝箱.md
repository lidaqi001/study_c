> --- 


    printf()函数用于显示格式化输出，它用变量的值来替换格式符，像这样：
        printf("%s 说计数是 %i", " 阿星 ", 21);
    当调用printf()时，可以包含任意数量的参数，但确保每个参数都要有一个对应的%格式符。
    如果想检查程序的退出状态，可以在Windows命令提示符中输入：
        echo %ErrorLevel%
    或在Linux或Mac终端中输入：
        echo $?


> ---

    在C语言中，布尔值是用数字表示的。对C语言来讲，数字0代表假的值。
    那什么数字代表真呢？任何不等于0的数字都将被当成真处理，因此下面的C代码也没错：
        int people_moshing = 34;
        if (people_moshing)
            take_off_glasses();
    事实上，C程序常用它作为“检查某个变量不为0”的简写。


> ---


    为了从此避免这个错误，可以不再将char指针设置为字符串字面值，像这样：
        char *s = "Some string";
    但是把指针设为字符串字面值又没错，问题出在你试图修改字符串字面值。
    如果你想把指针设成字符串字面值，必须确保使用了const关键字：
        const char *s = "some string";
    这样一来，如果编译器发现有代码试图修改字符串，就会提示编译错误：
        s[0] = 'S';
        monte.c:7: error: assignment of read-only location


> ---


    有一种小工具叫过滤器（filter），它逐行读取数据，对数据进行处理，再把数据写到某个地方。
    如果你的计算机是Unix，或你在Windows上安装了Cygwin，就已经拥有很多过滤器工具了。
        head：显示文件前几行的内容。
        tail：显示文件最后几行的内容。
        sed：流编辑器（stream editor），用来搜索和替换文本。
    等会儿你会看到如何把多个过滤器组合在一起，形成过滤器链。



> ---


    为什么把一个很大的数保存到short中会变成负数？
    数字以二进制保存，二进制的100 000看起来像这样：
        x <- 0001 1000 0110 1010 0000
    当计算机想把这个值保存到short时，发现只能保存2个字节，所以只保存了数字右半边：
        y <- 1000 0110 1010 0000
    最高位是1的二进制有符号数会被当成负数处理，它等价于下面的十进制数：
        -31072


> ---


    处理二进制值时，要是能够以某种方法在字面值中指定0和1就好了，比如：
        int x = 01010100;
    可惜的是，C语言不支持二进制字面值，不过它支持十六进制字面值。
    每当C语言看到0x开头的数字，就认为它是以16为基数的数字：
        int x = 0x54;	// 不是十进制数54。
    如何在十六进制与二进制之间进行转换？
    这比二进制与十进制之间的转换要容易些吗？
    是的，可以把十六进制数逐位转换为二进制数：
                   0x54
                    /  \
          这是5：0101    这是4：0100
    每一个十六进制数对应一个长度为4的二进制数。
    只要知道数字0到15的二进制形式，就能很快地在心中完成转换。



> ---


    函数与宏
    宏用来在编译前重写代码，这里的几个宏va_start、va_arg和va_end看起来很像函数，但实际上隐藏在它们背后的是一些神秘的指令。
    在编译前，预处理器会根据这些指令在程序中插入巧妙的代码。


> ---


    什么是位置无关代码？
    位置无关代码就是无论计算机把它加载到存储器的哪个位置都可以运行的代码。
    想象你有一个动态库，它要使用加载点500个字节以外的某个全局变量的值，那么如果操作系统把库加载到其他地方就会出错。
    只要让编译器创建位置无关的代码，就可以避免这种问题。
    包括Windows在内的一些操作系统在加载动态库时会使用一种叫存储器映射的技术，也就是说所有代码其实都是位置无关的。
    若你在Windows上用刚刚那条命令编译代码，gcc可能会给出一条警告，告诉你不需要-fPIC选项。你既可以奉命删除它，也可以当作没看见。


> ---


    什么是内核？
    在大部分计算机上，系统调用就是操作系统内核中的函数。什么是内核？虽然你从来没在屏幕上看到过它，但内核其实一直都在那里控制计算机。内核是计算机中最重要的程序，它主管三样东西：
        进程
            只有当内核把程序加载到存储器时程序才能运行。内核创建进程，并确保它们得到了所需资源。
            内核同时也会留意那些变得贪得无厌或者已经崩溃的进程。
        存储器
            计算机所能提供的存储器资源是有限的，因此内核必须小心翼翼地分配每个进程所能使用的存储器大小。
            内核还能把部分存储器交换到磁盘从而增加虚拟存储器空间。
        硬件
            内核利用设备驱动与连接到计算机上的设备交互。
            你的程序在不了解键盘、屏幕和图形处理器的情况下就能使用它们，因为内核会代表你与它们交涉。
    系统调用是程序用来与内核对话的函数。

> ---

    // 描述符表
    0   =>  键盘    =>  标准输入    (系统默认)
    1   =>  屏幕    =>  标准输出    (系统默认)
    2   =>  屏幕    =>  标准错误    (系统默认)
    3   =>  例:数据库链接   =>  进程也可能打开其他形式的数据流  (不固定,程序创建的各种数据流)

    难怪重定向错误输出要用 “2>”
    你可以在命令行用 “>” 运算符重定向标准输出，用 “2>” 重定向标准错误：
    ./myprog > output.txt 2> errors.log
    现在，知道为什么标准错误要用“2 >”来重定向了吧，因为2 是标准错误在描述符表中的编号。
    在很多操作系统中，也可以用“1 >”来重定向标准输出。
    而在类Unix操作系统中，可以用以下命令把标准错误和标准输出重定向到一个地方：
                ./myprog 2>&1
                         /  \
    “2>”表示“重定向标准错误”。  \
                            “&1”表示“到标准输出”。