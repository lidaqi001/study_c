> ## 入门

> ---
> 第1章

    简单的语句就是命令。
    块语句被{和}包围。
    如果条件为真，if语句就会运行代码。
    switch语句高效地检查了一个变量的多种取值。
    可以用&&和||把多个条件组合在一起。
    每个程序都需要一个main()函数。
    #include将外部代码（如用来输入输出的代码）包含进来。
    源文件的文件名应该以.c结尾。
    需要在运行之前先编译C程序。
    gcc是最流行的C编译器。
    可以在命令行中用&&操作符在编译之后马上运行程序，前提是必须编译成功。
    - o指定了输出文件。
    count ++ 表示计数加1。
    count -- 表示计数减1。
    只要条件为真，while就会重复执行代码。
    do - while至少执行一次代码。
    用for写循环更简洁。

> ## 存储器和指针

> ---
> 第2章

    scanf( “ % i”,  & x)可以让用户直接输入数字x。
    char指针变量x可以这么声明：char *x。
    用字符串初始化数组，数组会复制字符串中的内容。
    &x返回x的地址。
    &x称为指向x的指针。
    局部变量保存在栈上。
    数组变量可以用作指针。
    用*a读取地址a中的内容。
    可以简单地用fgets(buf,size, stdin)输入文本。

> ## 字符串

> ---
> 第2章

    字符串字面值保存在只读存储器中。
> ---
> 第2.5章

    string.h头文件包含了有用的字符串处理函数。
    strstr(a,b)可以返回字符串b在字符串a中的地址。
    字符串数组是数组的数组。
    可以用char strings[ … ][ … ]创建数组的数组。
    strcmp()可以比较字符串。
    strcat()可以连接字符串。
    strchr()用来在字符串中找到某个字符的位置。
    strcpy()可以复制字符串。
    strlen()可以得到字符串的长度。

> ## 数据流

> ---
> 第3章

    printf()和scanf()使用标准输出和标准输入来交互。
    标准输出默认在显示器上显示数据。
    标准输入默认从键盘读取数据。
    可以用重定向把标准输入、标准输出和标准错误连接到其他地方。
    标准错误专门用来输出错误消息。
    可以用fprintf(stderr, … )把数据打印到标准错误。
    可以用fopen(“文件名”, 模式)创建你自己的数据流。
    三种模式分别是w（写入）、r（读取）、a（追加）。
    命令行参数以字符串指针数组的形式传递给main()。
    用getopt()函数读取命令行选项很方便。

> ## 数据类型
    
> ---
> 第2章

    不同计算机的int的大小不同。
> ---
> 第4章

    char是数值。
    大整数用long。
    小整数用short。
    普通整数用int。
    一般的浮点数用float。
    高精度的浮点数用double。

> ## 多个文件

> ---
> 第4章

    函数的声明与定义分离。
    把声明放在头文件中。
    用#include <> 包含标准库头文件。
    用#include“”包含本地头文件。
    把目标代码保存到文件中，提高构建速度。
    使用make管理代码构建过程。

> ## 结构

> ---
> 第5章

    结构把数据类型组合在一起。
    可以用“点表示法”读取结构中的字段
    可以像初始化数组那样初始化结构。
    有了“ -> ”表示法，就能用结构指针更新字段，十分方便。
    可以用typedef为数据类型创建别名。
    可以用“指定初始化器”按名设置结构或联合的字段。

> ## 联合和位字段

> ---
> 第5章

    联合可以在同一个存储器单元中保存不同的数据类型。
    可以用枚举创建一组符号。
    可以用位字段控制结构中的某些位。

> ## 数据结构
    
> ---
> 第6章
    
    动态数据结构使用递归结构。
    链表是动态数据结构。
    链表比数组更容易扩展。
    递归结构包含一个或多个链向相同结构数据的链接。
    在链表中插入数据很方便。

> ## 动态存储

> ---
> 第6章
    
    栈用来保存局部变量。
    与栈不同，堆存储器不会自动释放。
    malloc()在堆上分配存储器。
    free()释放堆上的存储器。
    strdup()会在把字符串复制到堆上。
    存储器泄漏是指存储器分配出去以后，你再也访问不到。
    valgrind可以帮助追踪存储器泄漏。

> ## 高级函数

> ---
> 第7章
    
    有了函数指针，就可以把函数当数据传递。
    函数指针是唯一不需要加*和&运算符的指针……
    每个函数的名字都是一个指向函数的指针。
    qsort()会排序数组。
    排序函数接收比较器函数指针。
    比较器函数决定如何排序两条数据。
    有了函数指针数组，就可以根据不同类型的数据运行不同的函数。
    参数数量可变的函数叫做“可变参数函数”。
    包含stdarg.h，就可以创建可变参数函数。


> ## 静态库与动态库

> ---
> 第8章
    
    #include <> 会查找包括/usr/include在内的标准目录。
    -L< 路径名 > 在标准lib目录列表中添加目录。
    -l< 库名 > 会链接标准目录（例如/usr/lib）下的文件。
    -I< 路径名 > 在标准include目录列表中添加目录。
    ar命令创建目标文件的存档。
    库存档名形如libXXX.a。
    库存档是静态链接的。
    gcc  -shared把目标文件转化为动态库。
    动态库在运行时链接。
    动态库在不同的操作系统上有不同的名字。
    动态库的后缀名有.so、.dylib、.dll和.dll.a等。

> ## 进程间通信

> ---
> 第9章
    
    system()会把字符串当成命令运行。
    fork()复制当前进程。
    fork()+exec()创建子进程。
    execl() = 参数列表
    execle() = 参数列表 + 环境变量
    execlp() = 参数列表 + 搜索PATH
    execv() = 参数数组
    execve() = 参数数组 + 环境变量
    execvp() = 参数数组 + 搜索PATH

> ---
> 第10章
    
    进程可以用管道通信。
    pipe()创建通信管道。
    exit()立即终止程序。
    waitpid()等待进程结束。
    fileno()查找描述符。
    dup2()复制数据流。
    信号是O/S发出的消息。
    用sigaction()处理信号。
    程序可以用raise()向自己发送信号。
    alarm()会在几秒钟以后向进程发送SIGALRM信号。
    kill命令发送信号。

> ---
> 第12章
 
    普通进程一次只做一件事。

> ## 网络与套接字

> ---
> 第11章

    Telnet是一个简易网络客户端。
    用socket()函数创建套接字。
    用fork()克隆子进程，同时处理多个客户端。
    服务器BLAB四部曲：
        B  = bind()
        L  = listen()
        A  = accept()
        B  = 开始对话
    DNS = Domain name system（域名系统）
    getaddrinfo()根据域名找地址

> ## 线程

> ---
> 第12章

    有了线程，进程一次就能做多件事。
    线程是“轻量级进程”。
    POSIX线程(pthread)是一个线程库。
    pthread_create()创建线程来运行函数。
    pthread_join()会等待线程结束。
    线程共享相同的全局变量。
    如果线程读取并更新了相同变量，代码的运行结果将不可预测。
    互斥锁是用来保护共享数据的锁。
    pthread_mutex_lock()在代码中创建互斥锁。
    pthread_mutex_unlock()释放互斥锁。