
## \#

> 问： card_name[0]是什么意思？
    
    答： 它是用户输入的第一个字符。如果用户输入了10，那么card_name[0]就将是1。
> 问： 总是得用/*和*/写注释吗？
    
    答： 如果你的编译器支持C99标准，就可以用//开始注释。编译器会将这一行的其余部分当做注释处理。
> 问： 怎么才能知道我的编译器支持哪种标准？

    答： 你可以查看编译器的文档。对gcc来讲，ANSI C、C99和C11这三种标准它全部支持。


## \#


> 问： 为什么我在Linux和Mac中运行程序时必须在程序前加上./？
    
    答： 因为在类Unix操作系统中，运行程序必须指定程序所在的目录，除非程序的目录已经列在了PATH环境变量中。
> 问： 为什么字符要从0开始编号？为什么不是1？
    
    答： 字符的索引值是一个偏移量：它表示当前要引用的这个字符到数组中第一个字符之间有多少字符。
> 问： 为什么要这样做？
    
    答： 计算机在存储器中以连续字节的形式保存字符，并利用索引计算出字符在存储器中的位置。如果计算机知道c[0]位于存储器1 000 000号单元，那么就可以很快地计算出c[96]在1 000 000 + 96号单元。
> 问： 为什么要设立哨兵字符？难道计算机就不知道字符串的长度吗？
    
    答： 通常不知道。记录数组的长度不是C语言的强项，字符串其实就是个数组。
> 问： C语言居然不知道数组有多长？
    
    答： 是的，虽然编译器有时可以通过分析代码计算出数组的长度，但一般情况下，C语言希望你来记录数组的长度。
> 问： 单、双引号有区别吗？
    
    答： 有区别，单引号通常用来表示单个字符，而双引号通常用来表示字符串。
> 问： 我应该用双引号（"）定义字符串，还是以显式字符数组的形式定义字符串？
    
    答： 通常应该用双引号来定义字符串。用双引号定义的字符串叫字符串字面值（string literal），比起字符数组，它输入起来也更方便。
> 问： 字符串字面值和字符数组有没有区别？
    
    答： 只有一个区别：字符串字面值是常量。
> 问： 那是什么意思？
    
    答： 也就是说这些字符一旦创建完毕，就不能再修改它们。
> 问： 如果我改了会怎么样？
    
    答： 这取决于编译器，gcc通常会显示总线错误（bus error）。
> 问： 总线错误？那是什么东西?
    
    答： C语言采取不同的方式在存储器中保存字符串字面值。总线错误意味着程序无法更新那一块存储器空间。


## \#


> 问： 为什么不能只写一个|和&？
    
    答： 也不是不行。&和|操作符总是计算两个条件，而&&和||可以跳过第二个条件。
> 问： 那还要|和&干什么呢？
    
    答： 对逻辑表达式求值只是它们的一个用处，它们还能对数字的某一位进行布尔运算。
> 问： 那是什么意思？
    
    答： 6 & 4等于 4，是因为当对6（二进制数110）和4（二进制数100）的每个二进制位布尔与时，就会得到4（二进制数100）。


## \#


> 问： 为什么我要用switch语句取代if？
    
    答： 当需要多次检查同一变量时，使用switch语句会更方便。
> 问： 使用switch语句有什么好处？
    
    答： 有这几个好处。第一，让代码更清晰，一段代码处理一个变量的结构，结构一目了然，相反，一连串的if语句就没那么清晰了；第二，可以用下落逻辑在不同的分支之间复用代码。
> 问： switch语句只能检查变量吗？它能检查值吗？
    
    答： 能，switch语句仅仅检查两个值是否相等。
> 问： 我能在switch语句中检查字符串吗？
    
    答： 不能用switch语句检查字符串或任何形式的数组，switch语句只能检查值。



## \#

> 问： 如果我创建了一个void函数，是否就意味它一定不能有return语句？
    
    答 ： 你还是可以包含return语句，但编译器很可能会产生一条警告消息。而且在void函数中包含return语句没有任何意义。
> 问： 真的吗？为什么没有意义？
    
    答： 因为如果你试图读取void函数的值，编译器会报错。


## \#


> 问： 如果我创建了一个void函数，是否就意味它一定不能有return语句？
    
    答 ： 你还是可以包含return语句，但编译器很可能会产生一条警告消息。而且在
void函数中包含return语句没有任何意义。 ①
> 问： 真的吗？为什么没有意义？
    
    答： 因为如果你试图读取void函数的值，编译器会报错。


## \#


> 问： C语言为什么需要编译？其他一些语言就不需要编译，比如JavaScript，是吗？
    
    答： 为了让代码执行起来更快，C语言需要编译。尽管有些语言不是编译型语言，但它们中的一些，像JavaScript和Python，为了提高速度通常会在幕后使用一些编译技术。
> 问： C++是另一个版本的C语言吗？
    
    答： 不是，虽然C++的设计初衷是为了扩展C，但现在看来远不止如此，人们最初创造C++和Objective-C都是为了用C语言写面向对象的程序。
> 问： C语言为什么看起来很像JavaScript、Java和C#等语言？
    
    答： C语言的语法非常简洁，因此影响了很多其他语言。
> 问： gcc这三个字母分别代表什么含义？
    
    答： GNU编译器套装（GNUCompiler Collection）。
> 问： 为什么是“套装”？难道不止C语言一种吗？
    
    答： GNU编译器套装可以用来编译很多语言，而C语言可能是人们在应用gcc时使用最多的语言。
> 问： 我能创建一个永无止尽的循环吗？
    
    答： 可以，如果循环条件的值是1，循环就会永无止尽地运行下去。
> 问： 创建一个永无止尽的循环是个好主意吗？
    
    答： 有时候是，通常在一些诸如网络服务器的程序中会使用无限循环（一个永无止尽的循环），程序会反复地做一件事直到有人停止它。但大部分的程序员使用循环是为了让它们在某个时刻停止。


## \#


> 问： 我在自己的机器上打印出了变量的单元号，但它不是4 100 000。是不是哪里做错了？
    
    答： 你没有做错，在不同机器中，程序用来保存变量的存储器单元号不同。
> 问： 为什么局部变量保存在栈里，而全局变量保存在其他地方？
    
    答： 局部变量和全局变量的用法不同。你永远只能得到一份全局变量，但如果写了一个调用自己的函数，就会得到同一个局部变量的很多个实例。
> 问： 存储器中的其他区域是用来做什么的？
    
    答： 你会在本书的后续章节中看到它们的作用。


## \#


> 问： 指针是真实的地址单元，还是某种形式的引用？
    
    答： 它们是进程存储器中真实编号的地址。
> 问： 为什么存储器是进程的？
    
    答： 计算机会为每个进程分配一个简版存储器，看起来就像是一长串字节。
> 问： 但存储器并非如此？
    
    答： 实际的存储器复杂多了，但细节对进程隐藏了起来，这样操作系统就可以在存储器中移动进程，或释放并重新加载到其他位置。
> 问： 存储器不仅仅是一长列字节？
    
    答： 物理存储器的结构十分复杂，计算机通常会将存储器地址分组映射到存储芯片的不同的存储体（memory bank）。
> 问： 我需要理解它是怎么映射的吗？
    
    答： 对大部分程序来说，你不需要关心机器组织存储器的细节。
> 问： 为什么我一定要用%p格式串来打印指针？
    
    答： 不一定要用%p，在大多数的现代计算机上可以用%li，但编译器可能会给出一条警告。
> 问： 为什么%p以十六进制显示存储器地址？
    
    答： 工程师通常以十六进制表示存储器地址。
> 问： 如果我们把读取存储器单元的内容称为“解引用”，那么指针是不是应该叫“引用”？
    
    答： 人们有时会把指针叫做“引用”，因为它引用了存储器中的某个地址单元。但C++程序员通常用“引用”表示C++中一个稍有不同的概念。


## \#


> 问： sizeof是一个函数吗？
    
    答： 不是，它是一个运算符。
> 问： 有什么区别？
    
    答： 编译器会把运算符编译为一串指令；而当程序调用函数时，会跳到一段独立的代码中执行。
> 问： 所以程序是在编译期间计算sizeof的？
    
    答： 没错，编译器可以在编译时确定存储空间的大小。
> 问： 为什么在不同的计算机上指针变量的大小不同？
    
    答： 在32位操作系统中，存储器地址以32位数字的形式保存，所以它叫32位操作系统。32位==4字节，所以64位操作系统要用8个字节来保存地址。
> 问： 如果我创建了一个指针变量，它位于存储器中吗？
    
    答： 是的，指针变量只不过是一个保存数字的变量罢了。
> 问： 我可以找到指针变量的地址吗？
    
    答： 可以用&运算符找到它的地址。
> 问： 我可以把指针转化为一般的数字吗？
    
    答： 在大多数操作系统中，可以这样做。C编译器通常会把long数据类型设为和存储器地址一样长。如果想要把指针p保存在long变量a中，可以输入a=(long)p，过几章我们会学习这种方法。
> 问： 是在大多数操作系统中吗？所以并不是全部？
    
    答： 并不是全部。


## \#


> 问： 我真的需要理解指针算术运算吗？
    
    答： 有的程序员不使用指针算术运算，因为它很容易出错，但你可以用它有效地处理数组数据。
> 问： 指针能做减法吗？
    
    答： 能，但小心别让指针越过数组的起点。
> 问： C语言什么时候对指针算术运算进行调整？
    
    答： 在编译器生成可执行文件时，编译器会根据变量的类型，用变量的大小乘以指针的增量或减量。
> 问： 然后呢？
    
    答： 假如编译器看到你对一个指向int数组的指针加2，就会用2乘以4（int的长度），然后对地址加8。
> 问： C语言在调整指针算术运算时用了sizeof运算符吗？
    
    答： 本质上如此，sizeof运算符的结果也是在编译时决定的，对各种数据类型，sizeof和指针算术运算都将使用相同的长度。
> 问： 指针可以相乘吗？
    
    答： 不可以。



## \#


> 问： 为什么编译器不直接告诉我“不能修改字符串”？
    
    答： 我们只是把cards声明成char *，编译并不知道这个变量指向字符串字面值。
> 问： 为什么字符串字面值要保存在只读存储器中？
    
    答： 因为它们专门用来表示常量。如果你写了一个打印“HelloWorld”的函数，一定不想让程序的其他部分修改“Hello World”这个字符串字面值。
> 问： 只读变量在所有操作系统中都不能够修改吗？
    
    答： 大部分操作系统都有这个规定，一些Cygwin的gcc版本允许修改字符串字面值，不会报错，但这样做常常是错的。
> 问： const到底是什么意思？它能让字符串变成只读吗？
    
    答： 加不加const，字符串字面值都是只读的，const修饰符表示，一旦你试图用const修饰过的变量去修改数组，编译器就会报错。
> 问： 在存储器中，不同的存储器段总是以相同的顺序出现吗？
    
    答： 在同一种操作系统中它们出现的顺序相同，不同操作系统之间略有差异，例如Windows的代码段就不在地址的低位。
> 问： 我还是不理解，为什么数组变量不保存在存储器中？既然它存在，就应该在某个地方，不是吗？
    
    答： 程序在编译期间，会把所有对数组变量的引用替换成数组的地址。也就是说在最后的可执行文件中，数组变量并不存在。既然数组变量从来不需要指向其他地方，有和没有其实都一样。
> 问： 每当我把一个新数组设为字符串字面值，程序实际上会复制字符串字面值的内容吗？
    
    答： 这取决于编译器，最后的机器代码既有可能把整个字符串字面值的内容复制到数组，也有可能程序会根据声明设置每个字符的值。
> 问： 你老是在说“声明”，它是什么意思？
    
    答： 声明是一段代码，它声称某样东西（变量或函数）存在；而定义说明它是什么东西。如果在声明了变量的同时将其设为某个值（例如int x = 4;），这段代码既是声明又是定义。
> 问： 为什么scanf()要被称为scanf()？
    
    答： scanf()其实表示“scanformatted”，它用来扫描带格式的输入。



## \#


> 问： 为什么要把数组定义成tracks[][80]而不是tracks[5][80]？
    
    答： 也可以这样定义，但编译器知道列表有5项，所以你可以省略5，写成[]。
> 问： 既然如此，为什么不直接写tracks[][]？
    
    答： 每首歌的名字不一样长，为了放下最长的歌名，需要让编译器分配足够大的空间。
> 问： 也就是说tracks数组中每个字符串都有80个字符？
    
    答： 程序会为每个字符串分配80个字符，即使歌名很短。
> 问： 所以tracks数组一共占了80×5=400字符？
    
    答： 没错。
> 问： 如果我忘了包含 string.h 这样的头文件会怎么样？
    
    答： 对于某些头文件来说，编译器会给出一个警告，但最后还是会包含它们；但对另一些来讲，编译器会直接提示编译错误。
> 问： 为什么我们要把tracks数组定义在函数外面？
    
    答： 我们把tracks放在全局域，全局变量可以在所有函数中使用。
> 问： 既然我们创建了两个函数，计算机会先运行哪一个？
    
    答： 程序总是首先运行main()函数。
> 问： 为什么我一定要把find_track()放在main()之前？
    
    答： 在调用函数前，编译器需要知道两件事，函数接收什么参数以及函数的返回类型是什么。
> 问： 如果我把main()放到前面会怎么样？
    
    答： 你会得到几个警告。



## \#


> 问： 既然有stdout和stderr，自然就有stdin吧？
    
    答： 有，如你所料，它代表标准输入。
> 问： 我可以打印stdin吗？
    
    答： 不可以。
> 问： 我可以从stdin中读取数据吗？
    
    答： 嗯，你可以用fscanf()来读取，它的用法和scanf()很像，区别是可以指定fscanf()从哪条数据流中读取数据。
> 问： 也就是说fscanf(stdin,...)和scanf()等价？
    
    答： 没错，它们完全相同。说到底，scanf()就是用fscanf(stdin, ...)实现的。
> 问： 我可以重定向标准错误吗？
    
    答： 可以，你可以用>重定向标准输出，2>重定向标准错误。
> 问： 所以我要写geo2json 2> errors.txt?
    
    答： 没错。



## \#


> 问： 为什么小工具要使用标准输入和标准输出？
    
    答： 有了它们，就可以轻易用管道将小工具们串连起来。
> 问： 为什么要把它们串连在一起？
    
    答： 小工具只能解决一个小技术问题，例如转换数据的格式，而无法解决整个问题。只有把它们组合在一起，才能解决大问题。
> 问： 到底什么是管道？
    
    答： 不同操作系统实现管道的方法不同，可能用存储器，也可能用临时文件。我们只要知道它从一端接收数据，在另一端发送数据就行了。
> 问： 如果两个程序用管道相连，第二个程序要不要等第一个程序执行完后才能开始运行？
    
    答： 不需要，两个程序可以同时运行，第一个程序一发出数据，第二个程序马上就可以处理。
> 问： 为什么小工具要使用文本？
    
    答： 文本是一种开放格式，程序员可以用文本编辑器来查看小工具的输出，并理解里面的内容，相比之下，二进制格式就难懂多了。
> 问： 我能用管道连接多个程序吗？
    
    答： 能啊，只要在每个程序前加上一个|就行了，一连串相连的进程就叫流水线（pipeline）。
> 问： 当我用管道连接多个进程时，< 与 > 分别重定向哪个进程的标准输入、哪个进程的标准输出？
    
    答： < 会把文件内容发送到流水线中第一个进程的标准输入， > 会捕获流水线中最后一个进程的标准输出。
> 问 ：当我在命令行中运行bermuda和geo2json程序时，它们外面的括号是必需的吗？
    
    答： 是的，这对括号保证了数据文件由bermuda程序的标准输入来读取。


## \#


> 问： 最多能有几条数据流？
    
    答： 这取决于操作系统。通常情况下，一个进程最多可以有256条数据流。但请记住，数据流的数量是有限的，用完后应该关闭它们。
> 问： 为什么FILE要大写？
    
    答： 说来话长，最早FILE是用宏定义的，而宏的名字通常都要大写。稍后会看到宏。


## \#


> 问： 我能合并两个选项吗？例如用-td now代替-d now –t。
    
    答： 可以，getopt()函数会全权处理它们。
> 问： 我可以改变选项之间的顺序吗？
    
    答： 可以，因为我们用循环读取选项，所以-d now -t、-t -d now、-td now都一样。
> 问： 也就是说，只要程序在命令行看到一个前缀为－值，就会把它当成选项处理？
    
    答： 是的，前提是它必须在命令行参数之前出现。
> 问： 如果我想在命令行参数使用负数怎么办？像set_temperature -c -4，程序会把4当作选项吗？
    
    答： 为了避免歧义，可以用--隔开参数和选项，比如set_temper-ature -c -- -4。getopt()看到--就会停止读取选项，程序会把后面的内容当成普通的命令行参数读取。


## \#


> 问： 为什么不同操作系统的数据类型大小不同？设成一样不是更明了？
    
    答： 为了适应硬件，C语言在不同的操作系统与处理器上使用不同的数据类型大小。
> 问： 怎么说？
    
    答： C语言诞生之初还是8位机的天下，但现在大部分计算机都是32位和64位的，因为C语言没有指定数据类型的具体大小，所以才能与时俱进。即使新的计算机出来，C语言还是能够很好地适应。
> 问： 8位、64位到底是什么意思？
    
    答： 从技术上讲，计算机的位数有多种含义，它既可以代表CPU指令的长度，也可以代表CPU一次从存储器读取数据的大小。实际上，位数是计算机能够处理的数值长度。
> 问： 这和int、double的大小有什么关系？
    
    答： 如果一台计算机能处理32位的数值，就会把基本数据类型（例如int）的大小设为32位。
> 问： 我知道int这样的整数是怎么工作的，但float或double是怎么保存的呢？计算机如何表示有小数点的数字呢？
    
    答： 一言难尽，大部分计算机使用了IEEE发布的标准（http://tinyurl.com/6defkv6）。
> 问： 我需要理解浮点数的工作原理吗？
    
    答： 不需要，大部分程序员使用float与double时不会关注它们的细节。



## \#


> 问： 也就是说int函数可以没有声明？
    
    答： 不一定，除非你想共享代码，马上你就会看到。
> 问： 我有点纳闷，你提到了编译器预处理，为什么编译器需要预处理？
    
    答： 严格意义上讲，编译器只完成编译的步骤，即把C源代码转化为汇编语言。但宽泛地讲，编译是将C源代码转化为可执行文件的整个过程，这个过程由很多阶段组成，而gcc允许你控制这些阶段。gcc会预处理和编译代码。
> 问： 什么是预处理？
    
    答： 预处理是把C源代码转化为可执行文件的第一个阶段。预处理会在正式编译开始之前修改代码，创建一个新的源文件。拿你的代码来说，预处理会读取头文件中的内容，插入主文件。
> 问： 预处理器会真的创建一个文件吗？
    
    答： 不会，为了提高编译的效率，编译器通常会用管道在两个阶段之间发送数据。
> 问： 为什么有的头文件用引号括起来，有的用尖括号？
    
    答： 严格来说，这是由编译器的工作方式决定的。通常情况下，引号表示以相对路径查找头文件，如果不加目录名，只包含一个文件名，编译器就会在当前目录下查找头文件；如果用了尖括号，编译器就会以绝对路径查找头文件。
> 问： 编译器在寻找头文件时会查找哪些目录？
    
    答： gcc知道标准库的头文件被保存在哪里，在类Unix操作系统中，头文件通常保存在 /usr/local/include 、 /usr/include 这些地方。
> 问： gcc就是这样找到 stdio.h的，是吗？
    
    答： 是的，在类Unix操作系统中， stdio.h 位于 /usr/include/stdio.h ；如果在Windows中安装了MinGW编译器， stdio.h 就很有可能在 C:\MinGW\include\stdio.h 中。
> 问： 我可以创建我自己的库吗？
    
    答： 可以，你会在后面几章中学到。

## \#

> 问： make很像ant？

    答： 应该说ant和rake ① 这样的构建工具像make才对，make是最早出现的用来从源代码自动构建程序的工具。
> 问： 编译源代码要做那么多事情，make真的那么管用吗？

    答： 是的，make非常有用。对小项目来说，make可能节约不了太多时间，但一旦有很多文件，手动编译、链接它们会很痛苦。
> 问： 如果我在Windows上写了一个makefile，在Mac或Linux上能用吗？

    答： makefile会调用底层操作系统的命令，所以有时不能在其他操作系统中使用。
> 问： 除了编译代码，我能用make做其他事情吗？

    答： 可以，虽然make一般用来编译代码，但你也可以用它充当命令行下的安装程序或源代码控制工具。事实上，任何可以在命令行中执行的任务，你都可以用make来做。

## \#

> 问： 结构就是数组吗？

    答： 不是数组，不过结构把多条数据组合在一起，这点和数组很像。
> 问： 数组变量就是一个指向数组的指针，那么结构变量是一个指向结构的指针吗？

    答： 不是，结构变量是结构本身的名字。
> 问： 我可以用下标[0]、[1]……访问结构字段吗？

    答： 不可以，你只能按名访问。
> 问： 结构就相当于其他语言中的类？

    答： 它们很相似，但在结构中添加方法可就没那么容易了。

## \#

> 问： 结构字段在存储器中是紧挨着摆放的吗？
    
    答： 有时两个字段之间会有小的空隙。
> 问： 为什么？

    答： 计算机总是希望数据能对齐字边界（word boundary）。如果计算机的字长是32位，就不希望某个变量（比如short）跨越32位的边界保存。
> 问： 所以计算机会留下一道空隙，然后在下一个32位字开始的地方保存short？

    答： 是的。
> 问： 也就是说，每个字段都占用一整个字？

    答： 不一定，计算机在两个字段之间留出空隙仅仅是为了防止某个字段跨越字边界。如果几个字段能放在一个字中，计算机就会那么做。
> 问： 为什么计算机如此在意字边界？

    答： 计算机按字从存储器中读取数据，如果某个字段跨越了多个字，CPU就必须读取多个存储器单元，并以某种方式把读到的值合并起来。
> 问： 这样会很慢吗？

    答： 会很慢。
> 问： 在Java那样的语言中，如果我把对象赋给变量，它不会复制对象，仅仅复制引用，为什么C语言不这样做？

    答： 在C语言中，所有赋值都会复制数据，如果你想复制数据的引用，就应该赋指针。
> 问： 结构名的问题我还没搞清楚，什么是结构名？什么是别名？

    答： 结构名是struct关键字后面的那个单词。假设你写的是structpeter_parker{ ... }，那么结构名就是peter_parker，当创建变量时，你会写struct peter_ parker x。
> 问： 那别名呢？

    答： 有时，你不想在声明变量时还使用struct关键字，那么就可以用typedef创建别名。typedefstruct peter_parker { ... }spider_man;里面的spider_man就是别名。
> 问： 什么是匿名结构？

    答： 匿名结构就是没有名字的结构，typedef struct { ... }spider_man;有一个叫spider_man的别名，但没有结构名。很多时候，如果创建了别名，也就不需要结构名了。

## \#

> 问： 为什么计算机要把值复制给形参变量？

    答： 计算机通过把值赋给函数形参的方式向函数传值，所有赋值都会复制值。
> 问： 为什么*t.age与(*t).age的含义不同？

    答： 因为计算机先对“点”运算符求值，然后对*运算符求值。

## \#

> 问： 为什么联合的大小取决于最长的字段？

    答： 计算机需要保证联合的大小固定。唯一的办法就是让它足够大，任何一个字段都能装得下。
> 问： 为什么C89表示法只能设置第一个字段？如果我传给联合float值，为什么不把它设为第一个float字段？

    答： 这么做是为了避免歧义。假设你有一个float字段和一个double字段，那么计算机应该把{2.1}保存成float还是double呢？每次都把值保存在第一个字段中，你就知道数据是怎么初始化的。

## \#

> 问： 为什么C语言不支持二进制字面值？

    答： 因为二进制字面值占了很大空间，而且十六进制通常写起来更快。
> 问： 为什么保存一个0到10的值需要4位？

    答： 4位可以保存0到二进制数1111（也就是15）的值，但3位最大只能保存二进制数111（也就是7）。
> 问： 如果我把9放到一个3位的字段中会怎样？

    答： 计算机会保存1，因为9的二进制是1001，所以计算机转换成001。
> 问： 位字段就是为了节省空间的吗？

    答： 不仅仅是为了节省空间，如果需要读取低层的二进制信息，位字段就会非常有用。
> 问： 能举个例子吗？

    答： 比如要读写某类自定义二进制文件。

## \#

> 问： 其他语言，比如Java，有内置链表，C语言有内置数据结构吗？

    答： C语言没有内置数据结构，你必须自己创建它们。
> 问： 要是我有一个很长的链表，如果我想使用第700个元素，就必须从第一个开始一路读下去吗？

    答： 是的，你必须这样做。
> 问： 这样可不好，本来我以为链表比数组好。

    答： 数据结构没有好与坏之分，只有适合或不适合于它的应用场合之分。
> 问： 也就是说如果我想快速地插入数据，就需要链表，但如果我想直接访问元素，就应该用数组。是这样吗？

    答： 完全正确。
> 问： 你给出的这个结构含有一个指向其他结构的指针。我能把指针换成一个递归定义的结构吗？

    答： 不行。
> 问： 为什么？

    答： C语言需要知道结构在存储器中占的具体大小，如果在结构中递归地复制它自己，那么两条数据就会不一样大。


## \#

> 问： 如果island结构用数组保存岛名，而不是字符指针，还需要用strdup()吗？

    答： 不需要，如果用数组，每个island结构都会保存自己的副本，不需要你自己创建。
> 问： 那为什么要在数据结构中使用字符指针而不是字符数组呢?

    答： 字符指针不会限制字符串的大小。如果用字符数组，需要提前决定字符串的长度。

## \#

> 问： 为什么“堆”要叫做“堆”？

    答： 因为计算机不会自动组织它，它只是一大“堆”数据而已。
> 问 ： 什么是“垃圾收集（garbage colloection）”？

    答： 一些语言会跟踪你在堆上分配的数据，当你不再使用这些数据时，就会释放它们。
> 问： 为什么C语言没有“垃圾收集”？

    答： C语言非常古老，发明它的时候，绝大多数语言都没有自动 “垃圾回收”机制。
> 问： 这个例子中，复制island名字的原因我知道，但为什么open和close的值不需要复制？

    答： open和close的值都设为了字符串字面值，而字符串字面值无法更新，即便多项数据引用了相同字符串也没关系。
> 问： strdup()函数实际上会调用malloc()函数吗？

    答： 这取决于C标准库是如何实现的，不过通常情况下，是这样的。
> 问： 我需要在程序结束前释放所有数据吗？

    答： 不必，操作系统会在程序结束时清除所有存储器。不过，你还是应该显式释放你创建的每样东西，这是一种好的习惯。

## \#

> 问： valgrind说泄漏的存储器是在第46行创建的，但我们却修改了另一行代码，为什么？

    答： 虽然数据“Loretta...”是由第46行代码放到堆上的，但泄漏却发生在变量（current->question）重新赋值的那一刻，因为当时变量指向的“Loretta...”还没有释放。创建数据不会发生泄漏，只有当程序失去了所有对数据的引用才会导致泄漏。
> 问： 那么valgrind是怎么拦截malloc()与free()的？

    答： malloc()和free()包含在C标准库中，而valgrind有一个库，里面有它自己的malloc()与free()。当用valgrind运行程序时，程序会使用valgrind的函数，而不是C标准库中的函数。
> 问： 为什么编译器在编译代码时不默认包含调试信息？

    答： 因为调试信息会使可执行文件变大，同时也可能让程序变得更慢。
> 问： valgrind这个名字的由来是什么？

    答： valgrind是英灵殿 ① 入口的名字，而valgrind（程序）为你打开了一扇通向计算机堆的大门。

## \#

> 问： char**是什么意思？是不是打错了？

    答： char**是一个指针，通常用来指向字符串数组。

##　＼＃

> 问： 如果函数指针是指针，为什么调用函数时不需要在它们前面加*？

    答：可加也可不加，可 以把代码中的match(ADS[i])换成(*match)(ADS[i])。
> 问： 我可以用&取得函数的地址吗？

    答： 当然，除了find(sports_or_workout)，还可以写find(&sports_or_workout)。
> 问： 那为什么不这么写？

    答： 即使省略*和&，C编译器也能识别它们，这样代码更好读。

##　＼＃

＞　问： 用来给字符串数组排序的比较器函数使用了char**，它是什么意思？

    答： 字符串数组中的每一项都是字符指针（char*），当qsort()调用比较器函数时，会发送两个指向数组元素的指针，也就是说比较器函数接收到的是指向字符指针的指针，在C语言中就是char**。
＞　问： 当调用strcmp()时，为什么是strcmp(*a, *b)而不是strcmp(a, b)？

    答： a、b的类型是char**，而strcmp()函数需要接收char*类型的值。
＞　问： qsort()会创建新数组吗？

    答： 不会，qsort()在原数组上进行改动。
＞　问： 为什么我的头有点疼？

    答： 别担心，指针很难用，如果你一点儿也不感到困扰，可能是想得还不够深。

## \#

> 问： 为什么函数指针的语法这么复杂？

    答： 因为当声明函数指针时，需要说明返回类型和参数类型，这就解释了为什么有那么多的括号。
> 问： 刚才那段代码看起来有点像其他语言中面向对象的代码，是吗？

    答： 的确很像，面向对象语言将一组函数（称为方法）与数据关联在一起。同样你也可以用函数指针将函数与数据关联在一起。
> 问： 也就是说C语言也是面向对象的？太好了。

    答： C语言不是面向对象语言，不过一些以C语言为基础的语言，例如Objective-C和C++，在底层使用函数指针时创建了很多面向对象的特性。

## \#

> 问： 我怎样才能知道计算机上哪些目录是标准库目录？

    答： 你需要查看编译器文档。在大多数类Unix操作系统中，标准库目录有/usr/lib和/usr/local/lib。
> 问： 我想把库存档放到 /usr/lib目录下，但计算机不许我那么做，为什么？

    答： 出于安全考虑，操作系统为了防止你一不小心破坏某个库，会禁止你往标准目录中写文件。
> 问： ar命令的存档格式在所有系统中都是一样的吗？

    答： 不是，虽然不同平台之间存档格式区别不大，但存档中目标代码的格式在不同操作系统中可谓天差地别。
> 问： 创建库存档以后能不能查看里面的内容？

    答： 可以，ar –t <文件名>会列出存档中的目标文件。
> 问： 存档会像可执行文件那样把目标文件链接在一起吗？

    答： 不会，目标文件以独立文件的形式保存在存档中。
> 问： 我可以把任何类型的文件放在存档中吗？

    答： 不可以，ar命令会先检查文件类型。
> 问： 我能从存档中提取某个目标文件吗？

    答： 可以的，你可以使用ar –x libhfsecurity.a encrypt.o命令把encrypt.o文件从libhfsecurity.a中提取出来。
> 问： 为什么要叫“静态”链接？

    答： 因为一旦链接以后就不能修改。静态链接就好比在咖啡中加入牛奶，混在一起就不能再分开。
> 问： 我能用Head First安全库保护银行数据的安全吗？

    答： 最好不要这么做。