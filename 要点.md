

## \#


> 计算机会为变量在存储器中分配空间。

> 局部变量位于栈中。

> 全局变量位于全局量段。

> 指针只是一个保存存储器地址的变量。

> &运算符可以找到变量的地址。

> *运算符可以读取存储器地址中的内容。

> *运算符还可以设置存储器地址中的内容。


## \#


> 数组变量可以被用作指针。

> 数组变量指向数组中第一个元素。

> 如果把函数参数声明为数组，它会被当作指针处理。

> sizeof运算符返回某条数据占用空间的大小。

> 也可以对某种数据类型使用sizeof，例如sizeof(int)。

> sizeof(指针)在32位操作系统中返回4，在64位操作系统中返回8。

## \#

> 数组变量可以用作指针……

> ……但数组变量和指针又不完全相同。

> 对数组变量和指针变量使用sizeof，效果不同。

> 数组变量不能指向其他地方。

> 把数组变量传给指针，会发生退化。

> 索引的本质是指针算术运算，所以数组从0开始。

> 指针变量具有类型，这样就能调整指针算术运算。

## \#

> 如果在变量声明中看到*，说明变量是指针。

> 字符串字面值保存在只读存储器中。

> 如果想要修改字符串，需要在新的数组中创建副本。

> 可以将char指针声明成为constchar *，以防代码用它修改字符串。

## \#

> 可以用char strings[...][...]来创建数组的数组。

> 第一组方括号用来访问外层数组。

> 第二组方括号用来访问每个内层数组中的元素。

> 有了 string.h 头文件，就可以使用C标准库中的字符串处理函数。

> 可以在一个C程序中创建多个函数，但计算机总是先运行main()。


## \#

> printf()函数把数据发送到标准输出。

> 默认情况下，标准输出会发送到显示器。

> 可以在命令行中用>将标准输出重定向到文件。

> scanf()从标准输入读取数据。

> 默认情况下，标准输入会从键盘读取数据。

> 可以在命令行中用<将标准输入重定向到文件。

> 标准错误专门用来输出错误消息。

> 可以用2>重定向标准错误。

## \#

> 如果想完成一个不同的任务，应该另外写一个小工具。

> 小工具应该使用标准输入和标准输出。

> 小工具通常读写文本数据。

> 可以用管道连接一个进程的标准输出和另一个进程的标准输入。

## \#

> main()函数有两个版本，一个有命令行参数，一个没有。

> 命令行参数通过两个变量传递给main()函数，一个是参数的计数，另一个是指针（指向参数字符串）数组。

> 命令行选项是以“-”开头的命令行参数。

> getopt()函数会帮助你处理命令行选项。

> 为了定义有效的选项，可以传给getopt()一个字符串，例如ae：。

> 选项之后的 “:”（冒号）表示该选项需要接收一个参数。

> getopt()会用optarg变量记录选项参数。

> 读取完全部的选项以后，应该用optind变量跳过它们。

## \#

> 如果编译器发现你调用了一个它没见过的函数，就会假设这个函数返回int。

> 所以如果想在定义函数前就调用它，就可能出问题。

> 函数声明在定义函数前就告诉编译器函数长什么样子。

> 如果在源代码顶端声明了函数，编译器就知道函数返回什么类型。

> 函数声明通常放在头文件中。

> 可以用#include让编译器从头文件中读取内容。

> 编译器会把包含进来的代码看成源文件的一部分。

## \#

> 为了共享代码，可以把代码放到一个单独的C文件中。

> 需要把函数声明放到一个单独的.h头文件中。

> 在所有需要使用共享代码的C文件中包含这个头文件。

> 在编译的命令中列出所有C文件。

## \#

> 编译大量文件非常的耗时。

> 可以把目标代码保存在 *.o 文件中，加快编译速度。

> gcc不但能从源文件，而且能从目标文件编译程序。

> make工具可以用来自动化代码的构建过程。

> make清楚文件之间的依赖关系，可以只编译那些修改过的文件。

> 你需要使用makefile告诉make如何构建代码。

> 处理makefile的格式时要小心，别忘了用tab来缩进，不是空格！

## \#

> 结构是一种由一系列其他数据类型组成的数据类型。

> 结构的大小固定。

> 结构字段按名访问，用<结构>.<字段名>语法（也叫“点表示法”）。

> 结构字段在存储器中保存的顺序和它们出现在代码中的顺序相同。

> 可以嵌套定义结构。

> typedef创建数据类型的别名。

> 用typedef定义结构时可以省略结构名。

## \#

> 当调用函数时，计算机会把值复制给形参变量。

> 可以像创建其他类型的指针那样创建结构指针。

> “指针->字段”等于“(*指针).字段”。

> “->”表示法省掉了括号，代码更易阅读。

## \#

> 可以用联合在同一个存储器单元中保存不同数据类型。

> “指定初始化器”按名设置字段的值。

> C99标准支持“指定初始化器”，C++不支持。

> 如果用{花括号}中的值初始化联合，这个值会以第一个字段的类型保存。

> 你完全可以读取联合中未初始化过的字段，编译器不会干涉。但要小心，因为这么做很有可能会出错。

> 枚举保存符号。

> 可以用位字段自定义字段的位数。

> 位字段应当声明为unsigned int。

## \#

> 可以用动态数据结构保存可变数量的数据项。

> 可以很方便地在链表这种数据结构中插入数据项。

> 在C语言中，动态数据结构通常用递归结构来定义。

> 递归结构中有一个或多个指向相同结构的指针。

> 栈用来保存局部变量，它由计算机管理。

> 堆用来保存长期使用的数据，可以用malloc()分配堆空间。

> sizeof运算符告诉你一个结构需要多少空间。

> 数据会一直留在堆上，直到用free()释放它。


## \#

> valgrind可以检查存储器泄漏。

> valgrind通过拦截对malloc()与free()的调用来工作。

> 程序在停止运行时，valgrind会打印留在堆上数据的详细信息。

> 编译代码时，如果在可执行文件中加上调试信息，valgrind可以提供更多信息。

> 多次运行程序可以缩小泄漏的范围。

> valgrind可以告诉你源文件的哪行代码把数据放到了堆上。

> valgrind可以用来检验泄漏是否已修复。

## \#

> 函数指针
    
    返回类型 
       ↓    (* 指针变量 )
       ↓         ↓      ( 参数类型 )
       ↓         ↓          ↓
    char**  (*names_fn)(char*,int)

> 函数指针数组

    
    声明函数指针（数组）。
    变量名是replies。
    命名完变量，下面开始声明函数将接收什么类型的参数。

    返回类型(数组中所有函数都是void函数。)
       |   ( *指针变量("[]":不仅仅是函数指针，还是函数指针数组) )
       |       |        ( 参数类型(只有一个参数,response类型) )
       |       |          |
       V       V          V
    void (*replies[])(response) = {dump, second_chance, marriage};

## \#

> 函数指针中保存了函数的地址。

> 函数名其实是函数指针。②(并不完全等于，函数名是L-value，在存储器中不分配变量。——译者注)

> 如果你有函数shoot()，那么shoot和&shoot都指向了shoot()函数。

> 可以用“返回类型(*变量名)(参数类型)”来声明新的函数指针。

> 如果fp是函数指针，那么可以用fp(参数，……)调用函数。

> 也可以用(*fp)(参数，……)，两种情况都能工作。

> C标准库中有一个叫qsort()的排序函数。

> qsort()接收指向比较器函数的指针，比较器函数可以比较两个值的大小。

> 比较器函数接收两个指针，分别指向待排序数组中的两项。

> 如果把数据保存在数组中，就可以用函数指针数组将函数与数据项关联起来。

## \#

> 接收数量可变参数的函数叫可变参数函数。

> 为了创建可变参数函数，需要包含 stdarg.h 头文件。

> 可变参数将保存在va_list中。

> 可以用va_start()、va_ arg()和va_end()控制va_ list。

> 至少需要一个普通参数。

> 读取参数时不能超过给出的参数个数。

> 需要知道要读取参数的类型。

## \#

> 使用尖括号（<>），编译器就会从标准目录中读取头文件。

> 常见的标准头文件目录有 /usr/include 和 C:\MinGW\include 。

> 一个库存档中有多个目标文件。

> 可以用ar –rcs libarchive.a file0.ofile1.o...创建存档。

> 库存档名应以 lib 开头，以 .a 结尾。

> 如果想链接一个叫 libfred.a 的存档，就使用-lfred选项。

> 在gcc命令中，-l标志应该在源代码文件后出现。
---
> 创建动态库

        -I : hfcal.h头文件(自定义头文件)所在目录地址
          |           -fPIC : 它告诉 gcc 你想创建位置无关代码(试试吧，不加也没有关系。)
          |             |
          V             V
    gcc -I ./includes -fPIC -c hfcal.c -o hfcal.o

        -shared 选项告诉 gcc 你想把.o目标文件转化为动态库。
            |
            V
    gcc -shared hfcal.o -o ./libs/libhfcal.so

    // 编译可执行程序
              -L : 指定自定义动态库目录
                |       -l+动态库名称(去除固定的 前缀lib,后缀.so),可以有多个-l参数
                |           |
                V           V 
    gcc app.o -L ./libs -lhfcal -o app

---

> 动态库在运行时链接程序。

> 用一个或多个目标文件创建动态库。

> 在一些机器上，需要用-fPIC选项来编译目标文件。

> -fPIC令目标代码位置无关。

> 在一些机器上，可以省略-fPIC。

> -shared编译选项可以创建动态库。

> 动态库在不同机器上名字不同。

> 如果把动态库保存在标准目录中，生活会变得更简单。

> 不然，就需要设置PATH变量和LD_LIBRARY_PATH变量。


## 系统调用

> 系统调用是操作系统中的函数。

> 当进行系统调用时，相当于调用你程序外面的代码。

> system()系统调用可以运行命令字符串。

> system()用起来方便，但也容易出错。

> exec()系统调用在运行程序时给了你更多控制权。

> exec()系统调用有很多版本。

> 系统调用出错时通常会返回－1，但不是绝对的。

> 系统调用在出错的同时将errno变量设为错误码。

## \#

> 系统调用是内核中的函数。

> exec()函数比system()提供了更多控制权。

> exec()函数替换当前进程。

> fork()函数复制当前进程。

> 系统调用在失败时通常返回－1。

> 系统调用失败以后会把errno变量设为错误码。


## \#

> exit()可以快速结束程序。

> 所有打开的文件都记录在描述符表中。

> 通过修改描述符表就可以重定向输入和输出。

> fileno()能在表中查找描述符。

> dup2()可以用来修改描述符表。

> waitpid()等待进程结束。

## 管道

> 父子进程可以用管道通信。

> pipe()函数创建一个管道和两个描述符。

> 一个描述符是管道的读取端，另一个是写入端。

> 可以把标准输入和标准输出重定向到管道。

> 父子进程各自使用管道的一端。


## 信号


> 操作系统用信号来控制进程。

> 程序通常用信号来结束。

> 进程收到信号后会运行信号处理器。

> 大部分错误信号的默认处理器会终止程序。

> 可以用sigaction()函数替换处理器。

> 可以用raise()向自己发送信号(信号升级)。

> 间隔定时器发送SIGALRM信号。

> alarm()函数设置间隔定时器。

> 每个进程只能有一个定时器。

> 不要同时使用sleep()和alarm()。

> kill命令可以向进程发送信号。

> kill –KILL一定可以终止进程。


## 网络与套接字

> 协议是一段结构化对话。

> 服务器连接本地端口。

> 客户端连接远程端口。

> 客户端和服务器使用套接字通信。

> 用send()向套接字写数据。

> 用recv()从套接字读数据。

> HTTP是一种网络协议。