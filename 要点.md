

## \#


> 计算机会为变量在存储器中分配空间。

> 局部变量位于栈中。

> 全局变量位于全局量段。

> 指针只是一个保存存储器地址的变量。

> &运算符可以找到变量的地址。

> *运算符可以读取存储器地址中的内容。

> *运算符还可以设置存储器地址中的内容。


## \#


> 数组变量可以被用作指针。

> 数组变量指向数组中第一个元素。

> 如果把函数参数声明为数组，它会被当作指针处理。

> sizeof运算符返回某条数据占用空间的大小。

> 也可以对某种数据类型使用sizeof，例如sizeof(int)。

> sizeof(指针)在32位操作系统中返回4，在64位操作系统中返回8。

## \#

> 数组变量可以用作指针……

> ……但数组变量和指针又不完全相同。

> 对数组变量和指针变量使用sizeof，效果不同。

> 数组变量不能指向其他地方。

> 把数组变量传给指针，会发生退化。

> 索引的本质是指针算术运算，所以数组从0开始。

> 指针变量具有类型，这样就能调整指针算术运算。

## \#

> 如果在变量声明中看到*，说明变量是指针。

> 字符串字面值保存在只读存储器中。

> 如果想要修改字符串，需要在新的数组中创建副本。

> 可以将char指针声明成为constchar *，以防代码用它修改字符串。

## \#

> 可以用char strings[...][...]来创建数组的数组。

> 第一组方括号用来访问外层数组。

> 第二组方括号用来访问每个内层数组中的元素。

> 有了 string.h 头文件，就可以使用C标准库中的字符串处理函数。

> 可以在一个C程序中创建多个函数，但计算机总是先运行main()。


## \#

> printf()函数把数据发送到标准输出。

> 默认情况下，标准输出会发送到显示器。

> 可以在命令行中用>将标准输出重定向到文件。

> scanf()从标准输入读取数据。

> 默认情况下，标准输入会从键盘读取数据。

> 可以在命令行中用<将标准输入重定向到文件。

> 标准错误专门用来输出错误消息。

> 可以用2>重定向标准错误。

## \#

> 如果想完成一个不同的任务，应该另外写一个小工具。

> 小工具应该使用标准输入和标准输出。

> 小工具通常读写文本数据。

> 可以用管道连接一个进程的标准输出和另一个进程的标准输入。

## \#

> main()函数有两个版本，一个有命令行参数，一个没有。

> 命令行参数通过两个变量传递给main()函数，一个是参数的计数，另一个是指针（指向参数字符串）数组。

> 命令行选项是以“-”开头的命令行参数。

> getopt()函数会帮助你处理命令行选项。

> 为了定义有效的选项，可以传给getopt()一个字符串，例如ae：。

> 选项之后的 “:”（冒号）表示该选项需要接收一个参数。

> getopt()会用optarg变量记录选项参数。

> 读取完全部的选项以后，应该用optind变量跳过它们。

## \#

> 如果编译器发现你调用了一个它没见过的函数，就会假设这个函数返回int。

> 所以如果想在定义函数前就调用它，就可能出问题。

> 函数声明在定义函数前就告诉编译器函数长什么样子。

> 如果在源代码顶端声明了函数，编译器就知道函数返回什么类型。

> 函数声明通常放在头文件中。

> 可以用#include让编译器从头文件中读取内容。

> 编译器会把包含进来的代码看成源文件的一部分。

## \#

> 为了共享代码，可以把代码放到一个单独的C文件中。

> 需要把函数声明放到一个单独的.h头文件中。

> 在所有需要使用共享代码的C文件中包含这个头文件。

> 在编译的命令中列出所有C文件。

## \#

> 编译大量文件非常的耗时。

> 可以把目标代码保存在 *.o 文件中，加快编译速度。

> gcc不但能从源文件，而且能从目标文件编译程序。

> make工具可以用来自动化代码的构建过程。

> make清楚文件之间的依赖关系，可以只编译那些修改过的文件。

> 你需要使用makefile告诉make如何构建代码。

> 处理makefile的格式时要小心，别忘了用tab来缩进，不是空格！

## \#

> 结构是一种由一系列其他数据类型组成的数据类型。

> 结构的大小固定。

> 结构字段按名访问，用<结构>.<字段名>语法（也叫“点表示法”）。

> 结构字段在存储器中保存的顺序和它们出现在代码中的顺序相同。

> 可以嵌套定义结构。

> typedef创建数据类型的别名。

> 用typedef定义结构时可以省略结构名。

## \#

> 当调用函数时，计算机会把值复制给形参变量。

> 可以像创建其他类型的指针那样创建结构指针。

> “指针->字段”等于“(*指针).字段”。

> “->”表示法省掉了括号，代码更易阅读。

## \#

> 可以用联合在同一个存储器单元中保存不同数据类型。

> “指定初始化器”按名设置字段的值。

> C99标准支持“指定初始化器”，C++不支持。

> 如果用{花括号}中的值初始化联合，这个值会以第一个字段的类型保存。

> 你完全可以读取联合中未初始化过的字段，编译器不会干涉。但要小心，因为这么做很有可能会出错。

> 枚举保存符号。

> 可以用位字段自定义字段的位数。

> 位字段应当声明为unsigned int。

## \#

> 可以用动态数据结构保存可变数量的数据项。

> 可以很方便地在链表这种数据结构中插入数据项。

> 在C语言中，动态数据结构通常用递归结构来定义。

> 递归结构中有一个或多个指向相同结构的指针。

> 栈用来保存局部变量，它由计算机管理。

> 堆用来保存长期使用的数据，可以用malloc()分配堆空间。

> sizeof运算符告诉你一个结构需要多少空间。

> 数据会一直留在堆上，直到用free()释放它。